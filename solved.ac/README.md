# solved.ac
[solved.ac class](https://solved.ac/class) 문제풀이 과정에서 있었던 이슈나 개념 등을 정리한 페이지입니다.

## c++의 입출력 속도를 빠르게 하는 방법
백준 11659번 문제는 겉보기엔 간단하지만, 구간합 개념과 입출력 지연시간을 최소화하여야 실행시간 1초를 맞출 수 있다.
C++에서 입출력 실행시간을 줄이는 방법은 다음과 같다.
```cpp
ios_base::sync_with_stdio(false);
cout.tie(NULL);
cin.tie(NULL);
```
main 함수 초반에 위와 같이 작성해 주고, 추가적으로 개행문자에 `endl` 대신 `'\n'` 을 사용해주면 된다. \\
참고자료는 [여기](https://velog.io/@hayounsong/%EB%B0%B1%EC%A4%80-11659%EB%B2%88%EA%B5%AC%EA%B0%84-%ED%95%A9-%EA%B5%AC%ED%95%98%EA%B8%B0-4-C-%ED%92%80%EC%9D%B4)

## graph
### 기존의 풀이법
코딩테스트를 준비하면서 graph 기반 문제를 많이 풀게 되었는데, python으로 풀 때는 다음과 같이 풀었었다. 
1. dictionary를 사용하여 각 점마다 연결된 다른 점들만을 list 상에 남아서 연결 노드를 만든다.
2. 시작 점부터 차례로 bfs 를 이용해 순회한다.
다른 사람의 답안을 보지는 않았고, 이 방법으로 풀었을 때 다 풀리길래 그냥 넘어갔었다. 
### 문제점 발견
하지만 11724번 문제에서 같은 방법인 map, vector, set을 사용했을 때 `시간초과`가 났다. 그래서 다른 포스팅을 찾아보니, graph 문제는 2차원 배열을 만든 후, 모든 점을 순회하는 방법으로 탐색하는 방법으로 많이 풀더라. \
내가 공부해야할 것은 아래 3가지 정도이다. \
**PROBLEM_1**. 2차원 배열을 이용한 가장 간단하고, 표준인 풀이법이 무엇인지 알아보기. \
**PROBLEM_2**. 내가 시도했던, map, set 등을 사용하는 방법이 왜 시간초과를 야기하는지 알아보기. 왜냐하면, 해시맵을 사용하며, 모든 점이 아니라 연결된 점들만 순회하도록 하는 이 알고리즘이 왜 더 시간이 오래걸리는지 이해가 안가기 때문. \
**PROBLEM_3**. bfs와 dfs 두 방법으로 풀어보기. 

### 다른사람 답안분석
[11724번 풀이 포스팅](https://jaimemin.tistory.com/637) \
알고리즘의 흐름은 같고, vector를 2차원 배열로 만든 후, 열은 고정, 행은 가변으로 맞춰놓고 문제를 풀었다. \
나와의 차이점은 나는 map에 key와 value 형태로 만들어서 코드를 작성했다는 것인데, 아무래도 vector의 열을 고정하는 과정에서 메모리를 크게 사용하고, 이 부분에서 연산 속도 차이가 발생하지 않았나 싶다. \

### PROBLEM_1
> 2차원 배열을 이용한 가장 간단하고, 표준인 풀이법이 무엇인지 알아보기. 
```cpp
int MAX = N+1;          // 정점이 1부터 시작하기 때문에 1을 더해준다.
vector<int> graph[MAX]; // 열의 크기가 MAX인 2차원 배열. 행은 가변
```
추가) 1차원 배열을 쉽게 초기화하는 방법
```cpp
bool visited[MAX]={false};  // 모든 값이 false로 초기화됨.
bool visited_2[MAX];        // 이렇게 초기화하지 않을 시, 쓰레기 값이 들어가서 visited_2[3] 이런식으로 호출하면 true가 반환된다.
```

### PROBLEM_2
> 내가 시도했던, map, set 등을 사용하는 방법이 왜 시간초과를 야기하는지 알아보기. 왜냐하면, 해시맵을 사용하며, 모든 점이 아니라 연결된 점들만 순회하도록 하는 이 알고리즘이 왜 더 시간이 오래걸리는지 이해가 안가기 때문.
ANSWER \
일단, PROBLEM_1에서 알게 된 가변길이 2차원 배열을 사용하면 내가 map, set을 사용하여 구현한 것과 같이 입력값에서 주어진 이웃한 점으로만 이동하게 된다. 이때 각 node에 해당하는 vector에 연결된 점들을 push_back 하기 때문. \
다만, map, set을 사용했을 때 시간이 더 걸리는 이유는 아마, 헤더 선언에서 시간이 더 걸리거나, 값을 할당하는 시간이 미묘하게 더 걸리는 것이거나, 그런 것이지 않을까 싶다. 또한, `vector[MAX]` 이런식으로 큰 규모의 메모리를 미리 할당하고 계산하는 경우 메모리에서 더 손해를 보지만, 프로세스는 더 빠른 것이 이유일 수도 있다. \
**아무튼 미묘한 차이일 뿐 알고리즘 구조는 같았다.** 

### PROBLEM_3
**TODO** : DFS, BFS 둘다 할 줄 알아야 하지만, 이런 유형은 BFS로 얼추 커버 가능하기 때문에, 나중에 해보기. 


